Dans le systeme existant, je veux intégrer l'authentification.
L'application est faite avec Clean Architecture et utilise bloc pour la gestion des états.
En tant que developpeur senior flutter, Analyse bien l'existant, comprendre, corrige si nécessaire mais ajoute la fonctionnalité d'authentification que j'ai demandé et les autres points que j'ai mentionné.
La premiere connexion, l'user doit être connecté à internet, ensuite on sauvegarde ces informations en local.
Lorque les données doivent être synchronisées, on vérifie si le token est toujours valide, sinon on le renouvelle avec le refresh token.
Si le refresh token est expiré, on redirige l'utilisateur vers la page de connexion.

En fonction de l'agent connecté, son rôle(agent, prestataire), la home page (dashboard) est différente.

Aussi, Remplace agentId par le username de l'utilisateur connecté dans les transferts(formulaire d'ajout) lors d'un ajout de transfert.

Pour se connecté : POST /auth/login, on envoie un matricule et un mot de passe {
  "username": "string",
  "password": "string"
}, on recupere un token et un refresh token. Exemple de reponse success:

{
    "token": {
        "access_token": "",
        "refresh_token": ""
    },
    "userinfo": {
        "id": "68ac4e448f2b158006528b0e",
        "username": "agent-001@gmail.com",
        "is_active": true,
        "roles": [
            {
                "created_at": "2025-05-18T11:04:43.598000",
                "updated_at": "2025-08-22T23:50:54.246000",
                "name": "agent",
                "description": null,
                "id": "682cb0812f8dbc359b2fe8e7",
                "slug": "agent",
                "permissions": [
                    "feedbacks:can-change",
                    "kyb:can-read-crops"
                ]
            }
        ],
        "is_superuser": false,
        "must_change_password": true,
        "permissions": [],
        "created_at": "2025-08-25T11:51:32.533000",
        "updated_at": "2026-01-20T08:54:22.081084+00:00"
    }
}

Ensuite, on tape sur un autre endpoint, on envoie le token, on recupere le profil de l'utilisateur. Exemple de requete:
GET /profiles/me avec le authorization en parametre
Exemple de réponse success :
{
  "matricule": "string",
  "fullname": "string",
  "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "is_active": true,
  "metadata": {
    "civility": "",
    "job_title": "", 
    "place_of_work": ""
  },
  "created_at": "2026-01-23T16:02:07.161Z",
  "updated_at": "2026-01-23T16:02:07.161Z"
}

Si must_change_password est true, on redirige l'utilisateur vers la page de changement de mot de passe : PUT /change-password/{id}, on envoie un mot de passe {"password": "string"}
Exemple de reponse success :
{"message": "Password successfully changed !"}

Met à jour la page de profile (ProfilePage) avec les informations de l'utilisateur et le bouton de deconnexion.

Après la connexion de l’utilisateur, et afin de permettre à l’application de fonctionner en mode hors ligne, certaines données de référence sont récupérées et stockées localement. Utilise le token pour authentifier les requetes.

La première catégorie de données concerne la répartition géographique : régions, départements, sous-préfectures, secteurs, zones de dénombrement (ZD), localites et quarters.

Détermination de la région de l’utilisateur

Si le champ region est renseigné dans le formulaire de connexion, cette valeur est utilisée.

Sinon, la région est récupérée depuis les métadonnées du profil utilisateur (place_of_work).

Récupération hiérarchique des données

À partir de la région identifiée, les données sont récupérées de manière hiérarchique :

Récupération des départements associés à la région

Pour chaque département, récupération des sous-préfectures

Pour chaque sous-préfecture, récupération des secteurs

Pour chaque secteur, récupération des zones de dénombrement (ZD)

Cette approche par itération permet d’obtenir l’ensemble complet de la répartition géographique propre à l’utilisateur, qui est ensuite persistée en local pour une utilisation hors ligne.

Endpoints utilisés

GET /territories/regions/{region_id}/departments

GET /territories/departments/{department_id}/sub-prefectures

GET /territories/sub-prefectures/{sub_prefecture_id}/sectors

GET /territories/sectors/{sector_id}/zds

GET /territories/zds/{zd_id}/localites

GET /territories/localites/{localite_id}/quarters

Utilisation dans l’application

Dans la page NewTransfertPage, les listes (départements, sous-préfectures, secteurs, ZD) sont initialisées à partir des données stockées localement.

Les champs du formulaire utilisent des listes déroulantes avec recherche, permettant une sélection fluide même en mode hors ligne : regionController, departementController, sousprefectureController, villageController = sectors

La deuxieme catégorie de données concerne les nom de magasins (warehouse): recupère la liste des warehouses stocker en local et utiliser dans le formulaire NewTransfertPage, le champs nomMagasinController.Champ liste déroulante avec recherche

Exemple de réponses :
{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "region_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}
{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "department_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}

{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "sub_prefecture_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}

Pour les warehouse :
{
  "items": [
    {
      "code": "string",
      "name": "string",
      "type": "string",
      "capacity": 0,
      "occupancy_rate": 0,
      "locality": "string",
      "gps_lat": 0,
      "gps_lon": 0,
      "construction_date": "2026-01-23",
      "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "status": "PENDING",
      "is_active": true,
      "created_at": "2026-01-23T17:02:52.432Z",
      "updated_at": "2026-01-23T17:02:52.432Z"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}


Mets tous les bases url dans .env avec flutter_dotenv.
Base url auth : https://coco-backend.com/auth/
Base url user : https://coco-backend.com/profiles/
base url territories(répartition géographique): https://coco-backend.com/territories/
base url warehouses: https://coco-backend.com/warehouse/


Les messages d'erreur : 422
{
  "code_error": "validation/request-validation-error",
  "details": [
    {
      "field": "body.25",
      "message": "JSON decode error"
    }
  ]
}
Les messages d'erreur : autre codes:
{
  "code_error": "validation/xxxxxx-error",
  "message": ""
}


// transfer_id = form_id
// Mettre l'image de la fiche (photoFiche) en base64
// Toutes les dates en date par http mais par ussd respecter cette nomenclature YYYYMMDD
// receiptCount nombre de reçus à ajouter dans les metadata.

Dans ce projet, mon code, en tant que developpeur senior, analyse bien et intègre les modifications pour l'ajout ou soumission d'une fiche de transfert.
1. Enlever submissionId et utiliser numeroFiche comme identifiant unique de la fiche de transfert.
2. Ajouter un bundle id (base de données local, formulaire...) unique de la fiche de transfert. Ce bundle id va être la concatenation des numéro de réçu (receiptNumber) qu'on ajoute dans une fiche de transfert.
3. Renommer photoFiche en image. À soumettre en base64 par http dans les fields.
4. Remplacer agentId par le username de l'utilisateur connecté dans les transferts(formulaire d'ajout) lors d'un ajout de transfert.
5. Changer transfer_id en form_id.
6. En ussd, respecter cette nomenclature YYYYMMDD en int pour les dates.
7. receiptCount est le nombre de reçus à ajouter dans les metadata.
8. Pour soumettre les données par http, voici comment faire. On soumet les données de la fiche et les reçus separement :
  - Lorqu'on recupére l'url presigné, on poste les données de la fiche comme ça en body : 
    final payload = {
      "form_id": formId,
      "fields": fieldsMap,
    };
  Dans fieldsMap en plus des informations de la fiche ajoute le bundle id et la campagne.
  Dans les metadata de l'url presigné pour poster les données, on ajoute ce parametre: X-Amz-Meta-Source : http.
  - Pour les reçus, on recupére une url presigné pour chaque reçus et on poste le réçu en body suivant : 
  final receiptPayload = {
            "form_id": submissionId,
            "fields": {
              "bundle_id": "ETGTRFRF926",
              "numeroRecu": receipt.receiptNumber,
              "image": base64Image,
              "campagne": "2025-2026",
            },
          }; 


 
Pour rendre les campagnes dynamiques on doit récupérer par api lors de la connexion :
- La premiere étape consiste à recupérer les commodités : GET /commodities enregistrer en local. On peut afficher dans le profil de l'utilisateur pour lui permettre de changer ou switcher de commodité.
- La deuxieme étape consiste à recupérer les campagnes uniquement avec status OPEN en parametre : GET /campaigns enregistrer en local.
Réponse de la liste des campagnes :
{
  "items": [
    {
      "name": "string",
      "code": "string",
      "commodity_code": "strin",
      "start_date": "2026-01-26T12:13:47.278Z",
      "end_date": "2026-01-26T12:13:47.278Z",
      "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "is_active": true,
      "status": "PENDING"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}
On va utiliser que celle active en fonction de la commodité selectionnée ou configurer dans le profil de l'utilisateur.
Il faut utiliser une commodité par defaut ANACARDE.