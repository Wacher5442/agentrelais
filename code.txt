Dans le systeme existant, je veux intégrer l'authentification.
L'application est faite avec Clean Architecture et utilise bloc pour la gestion des états.
En tant que developpeur senior flutter, Analyse bien l'existant, comprendre, corrige si nécessaire mais ajoute la fonctionnalité d'authentification que j'ai demandé et les autres points que j'ai mentionné.
La premiere connexion, l'user doit être connecté à internet, ensuite on sauvegarde ces informations en local.
Lorque les données doivent être synchronisées, on vérifie si le token est toujours valide, sinon on le renouvelle avec le refresh token.
Si le refresh token est expiré, on redirige l'utilisateur vers la page de connexion.

En fonction de l'agent connecté, son rôle(agent, prestataire), la home page (dashboard) est différente.

Aussi, Remplace agentId par le username de l'utilisateur connecté dans les transferts(formulaire d'ajout) lors d'un ajout de transfert.

Pour se connecté : POST /auth/login, on envoie un matricule et un mot de passe {
  "username": "string",
  "password": "string"
}, on recupere un token et un refresh token. Exemple de reponse success:

{
    "token": {
        "access_token": "",
        "refresh_token": ""
    },
    "userinfo": {
        "id": "68ac4e448f2b158006528b0e",
        "username": "agent-001@gmail.com",
        "is_active": true,
        "roles": [
            {
                "created_at": "2025-05-18T11:04:43.598000",
                "updated_at": "2025-08-22T23:50:54.246000",
                "name": "agent",
                "description": null,
                "id": "682cb0812f8dbc359b2fe8e7",
                "slug": "agent",
                "permissions": [
                    "feedbacks:can-change",
                    "kyb:can-read-crops"
                ]
            }
        ],
        "is_superuser": false,
        "must_change_password": true,
        "permissions": [],
        "created_at": "2025-08-25T11:51:32.533000",
        "updated_at": "2026-01-20T08:54:22.081084+00:00"
    }
}

Ensuite, on tape sur un autre endpoint, on envoie le token, on recupere le profil de l'utilisateur. Exemple de requete:
GET /profiles/me avec le authorization en parametre
Exemple de réponse success :
{
  "matricule": "string",
  "fullname": "string",
  "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "is_active": true,
  "metadata": {
    "civility": "",
    "job_title": "", 
    "place_of_work": ""
  },
  "created_at": "2026-01-23T16:02:07.161Z",
  "updated_at": "2026-01-23T16:02:07.161Z"
}

Si must_change_password est true, on redirige l'utilisateur vers la page de changement de mot de passe : PUT /change-password/{id}, on envoie un mot de passe {"password": "string"}
Exemple de reponse success :
{"message": "Password successfully changed !"}

Met à jour la page de profile (ProfilePage) avec les informations de l'utilisateur et le bouton de deconnexion.

Après la connexion de l’utilisateur, et afin de permettre à l’application de fonctionner en mode hors ligne, certaines données de référence sont récupérées et stockées localement. Utilise le token pour authentifier les requetes.

La première catégorie de données concerne la répartition géographique : régions, départements, sous-préfectures, secteurs, zones de dénombrement (ZD), localites et quarters.

Détermination de la région de l’utilisateur

Si le champ region est renseigné dans le formulaire de connexion, cette valeur est utilisée.

Sinon, la région est récupérée depuis les métadonnées du profil utilisateur (place_of_work).

Récupération hiérarchique des données

À partir de la région identifiée, les données sont récupérées de manière hiérarchique :

Récupération des départements associés à la région

Pour chaque département, récupération des sous-préfectures

Pour chaque sous-préfecture, récupération des secteurs

Pour chaque secteur, récupération des zones de dénombrement (ZD)

Cette approche par itération permet d’obtenir l’ensemble complet de la répartition géographique propre à l’utilisateur, qui est ensuite persistée en local pour une utilisation hors ligne.

Endpoints utilisés

GET /territories/regions/{region_id}/departments

GET /territories/departments/{department_id}/sub-prefectures

GET /territories/sub-prefectures/{sub_prefecture_id}/sectors

GET /territories/sectors/{sector_id}/zds

GET /territories/zds/{zd_id}/localites

GET /territories/localites/{localite_id}/quarters

Utilisation dans l’application

Dans la page NewTransfertPage, les listes (départements, sous-préfectures, secteurs, ZD) sont initialisées à partir des données stockées localement.

Les champs du formulaire utilisent des listes déroulantes avec recherche, permettant une sélection fluide même en mode hors ligne : regionController, departementController, sousprefectureController, villageController = sectors

La deuxieme catégorie de données concerne les nom de magasins (warehouse): recupère la liste des warehouses stocker en local et utiliser dans le formulaire NewTransfertPage, le champs nomMagasinController.Champ liste déroulante avec recherche

Exemple de réponses :
{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "region_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}
{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "department_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}

{
  "items": [
    {
      "id": "string",
      "code": "string",
      "name": "string",
      "sub_prefecture_id": "string"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}

Pour les warehouse :
{
  "items": [
    {
      "code": "string",
      "name": "string",
      "type": "string",
      "capacity": 0,
      "occupancy_rate": 0,
      "locality": "string",
      "gps_lat": 0,
      "gps_lon": 0,
      "construction_date": "2026-01-23",
      "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "status": "PENDING",
      "is_active": true,
      "created_at": "2026-01-23T17:02:52.432Z",
      "updated_at": "2026-01-23T17:02:52.432Z"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}


Mets tous les bases url dans .env avec flutter_dotenv.
Base url auth : https://coco-backend.com/auth/
Base url user : https://coco-backend.com/profiles/
base url territories(répartition géographique): https://coco-backend.com/territories/
base url warehouses: https://coco-backend.com/warehouse/


Les messages d'erreur : 422
{
  "code_error": "validation/request-validation-error",
  "details": [
    {
      "field": "body.25",
      "message": "JSON decode error"
    }
  ]
}
Les messages d'erreur : autre codes:
{
  "code_error": "validation/xxxxxx-error",
  "message": ""
}


// transfer_id = form_id
// Mettre l'image de la fiche (photoFiche) en base64
// Toutes les dates en date par http mais par ussd respecter cette nomenclature YYYYMMDD
// receiptCount nombre de reçus à ajouter dans les metadata.

Dans ce projet, mon code, en tant que developpeur senior, analyse bien et intègre les modifications pour l'ajout ou soumission d'une fiche de transfert.
1. Enlever submissionId et utiliser numeroFiche comme identifiant unique de la fiche de transfert.
2. Ajouter un bundle id (base de données local, formulaire...) unique de la fiche de transfert. Ce bundle id va être la concatenation des numéro de réçu (receiptNumber) qu'on ajoute dans une fiche de transfert.
3. Renommer photoFiche en image. À soumettre en base64 par http dans les fields.
4. Remplacer agentId par le username de l'utilisateur connecté dans les transferts(formulaire d'ajout) lors d'un ajout de transfert.
5. Changer transfer_id en form_id.
6. En ussd, respecter cette nomenclature YYYYMMDD en int pour les dates.
7. receiptCount est le nombre de reçus à ajouter dans les metadata.
8. Pour soumettre les données par http, voici comment faire. On soumet les données de la fiche et les reçus separement :
  - Lorqu'on recupére l'url presigné, on poste les données de la fiche comme ça en body : 
    final payload = {
      "form_id": formId,
      "fields": fieldsMap,
    };
  Dans fieldsMap en plus des informations de la fiche ajoute le bundle id et la campagne.
  Dans les metadata de l'url presigné pour poster les données, on ajoute ce parametre: X-Amz-Meta-Source : http.
  - Pour les reçus, on recupére une url presigné pour chaque reçus et on poste le réçu en body suivant : 
  final receiptPayload = {
            "form_id": submissionId,
            "fields": {
              "bundle_id": "ETGTRFRF926",
              "numeroRecu": receipt.receiptNumber,
              "image": base64Image,
              "campagne": "2025-2026",
            },
          }; 


 
Pour rendre les campagnes dynamiques on doit récupérer par api lors de la connexion :
- La premiere étape consiste à recupérer les commodités : GET /commodities enregistrer en local. On peut afficher dans le profil de l'utilisateur pour lui permettre de changer ou switcher de commodité.
- La deuxieme étape consiste à recupérer les campagnes uniquement avec status OPEN en parametre : GET /campaigns enregistrer en local.
Réponse de la liste des campagnes :
{
  "items": [
    {
      "name": "string",
      "code": "string",
      "commodity_code": "strin",
      "start_date": "2026-01-26T12:13:47.278Z",
      "end_date": "2026-01-26T12:13:47.278Z",
      "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "is_active": true,
      "status": "PENDING"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}
On va utiliser que celle active en fonction de la commodité selectionnée ou configurer dans le profil de l'utilisateur.
Il faut utiliser une commodité par defaut ANACARDE.

/// 
Sur la base de l'existant, L'application est faite avec Clean Architecture et utilise bloc pour la gestion des états.
En tant que devéloppeur sénior analyse bien le code existant et dans le code ajoute une nouvelle fonctionnalité(feature) pour chargement et déchargement. 
Cette fonctionnalité est pour le prestataire, nécessite la connexion internet vu que sa zone de travail est couverte par internet.
- Sur la home page du prestataire, afficher la liste des chargements avec option de recherche par numéro de fiche (sheet_number, sticker_code)
Un chargement est un transfert(chargement ou déchargement) avec le statut en attente.
Le prestataire doit pouvoir voir les détails d'un chargement, donner sont ok pour passer au contrôle avant déchargement.
Quand il donne sont OK pour le chargement, le statut devient Ok pour contrôle(OK_FOR_CONTROL). Et là les études seront faites, par la suite de quoi il peut venir modifier ou ajouter des informations sur le chargement.

Les infos à ajouter sont celles relevé après l'étude.
"dest_date_dechargement": "2026-01-27",
"dest_heure": "09:15:04.930Z",
"dest_nom_exportateur": "string",
"dest_code_exportateur": "string",
"dest_port_usine_dechargement": "string",
"dest_pont_bascule": "string",
"dest_nom_magasin": "string",
"dest_kor": "string",
"dest_nombre_sacs_decharges": 0,
"dest_nombre_sacs_rembourses": 0,
"dest_taux_humidite": 0,
"dest_poids_brut": 0,
"dest_tare": 0,
"dest_poids_net": 0,
"dest_prix_kg": 0,
S'il saisit et valide, le statut passe à dechargé. À la suite de quoi on doit afficher l'element dans la liste des déchargements.

- Sur la liste de déchargement, le prestataire doit pouvoir voir les détails d'un déchargement, modifier le KOR uniquement(dest_kor). 
Mais attention, le KOR ne peut être modifié qu'une seule fois par l'utilisateur. Donc mettre les contrôles nécessaires voir des localstorage pour verifier s'il a deja modifié une fois.

Voici un exemple de json de réponse de l'api pour les chargements & déchargements : GET /commodities/transfers
{
  "items": [
    {
      "typeTransfert": "string",
      "denomination": "string",
      "marqueCamion": "string",
      "region": "string",
      "departement": "string",
      "sousPrefecture": "string",
      "village": "string",
      "destinationVille": "string",
      "date": "2026-01-27",
      "thDepart": "string",
      "acheteur": "string",
      "destinateur": "string",
      "codeAcheteur": "string",
      "nomMagasin": "string",
      "sacs": 0,
      "poids": 0,
      "prix": 0,
      "nomTransporteur": "string",
      "contactTransporteur": "string",
      "immatriculation": "string",
      "remorque": "string",
      "avantCamion": "string",
      "nomChauffeur": "string",
      "permisConduire": "string",
      "dest_date_dechargement": "2026-01-27",
      "dest_heure": "09:15:04.930Z",
      "dest_nom_exportateur": "string",
      "dest_code_exportateur": "string",
      "dest_port_usine_dechargement": "string",
      "dest_pont_bascule": "string",
      "dest_nom_magasin": "string",
      "dest_kor": "string",
      "dest_nombre_sacs_decharges": 0,
      "dest_nombre_sacs_rembourses": 0,
      "dest_taux_humidite": 0,
      "dest_poids_brut": 0,
      "dest_tare": 0,
      "dest_poids_net": 0,
      "dest_prix_kg": 0,
      "numeroFiche": "string",
      "campagne": "string",
      "bundle_id": "string",
      "sticker": "string",
      "image": "string",
      "status": "string",
      "created_at": "2026-01-27T09:15:04.930Z",
      "updated_at": "2026-01-27T09:15:04.930Z"
    }
  ],
  "total": 0,
  "page": 1,
  "size": 1,
  "pages": 0
}

ULR POUR UPDATE UN CHARGEMENT OU UN DECHARGEMENT : 
PATCH /commodities/transfer/{sheet_number}/{code_campaign}
Body : {
  "typeTransfert": "string",
  "denomination": "string",
  "marqueCamion": "string",
  "region": "string",
  "departement": "string",
  "sousPrefecture": "string",
  "village": "string",
  "destinationVille": "string",
  "date": "2026-01-27",
  "thDepart": "string",
  "acheteur": "string",
  "destinateur": "string",
  "codeAcheteur": "string",
  "nomMagasin": "string",
  "sacs": 0,
  "poids": 0,
  "prix": 0,
  "nomTransporteur": "string",
  "contactTransporteur": "string",
  "immatriculation": "string",
  "remorque": "string",
  "avantCamion": "string",
  "nomChauffeur": "string",
  "permisConduire": "string",
  "dest_date_dechargement": "2026-01-27",
  "dest_heure": "09:20:16.222Z",
  "dest_nom_exportateur": "string",
  "dest_code_exportateur": "string",
  "dest_port_usine_dechargement": "string",
  "dest_pont_bascule": "string",
  "dest_nom_magasin": "string",
  "dest_kor": "string",
  "dest_nombre_sacs_decharges": 0,
  "dest_nombre_sacs_rembourses": 0,
  "dest_taux_humidite": 0,
  "dest_poids_brut": 0,
  "dest_tare": 0,
  "dest_poids_net": 0,
  "dest_prix_kg": 0
}


GET TRANSFERT (CHARGEMENT & DECHARGEMENT) : 
GET /commodities/transfer/{sheet_number}/{code_campaign}

UPDATE status :
PATCH /commodities/transfer/{sheet_number}/{code_campaign}/status
{
  "status": "PENDING"
}
Available values : PENDING, VALIDATION, RECEIVED, UNLOADED, OK_FOR_CONTROL, REJECTED, RETURNED

BASE_URL : https://gisco.com/commodities

Reste fidèle au design existant avec les nouvelles page que tu vas créer, utilise dio déja configuré avec le token

Ce qui est fait c'est bon mais quelque corrections à apporter, 
pour eviter de melanger les feature, je préfère que tu enlève la fonctionnalité chargement & déchargement de la feature transfert et de créer une feature dédié(avec les models, datasources, blocs et pages) pour les chargements & déchargements.
Laisse la feature de transfert comme c'etait et crée pour toi.
Parceque la liste peut avoir des valeurs nulls pour eviter des exceptions ou erreurs:
{
    "items": [
        {
            "typeTransfert": "2",
            "denomination": null,
            "marqueCamion": null,
            "region": null,
            "departement": null,
            "sousPrefecture": "1502",
            "village": null,
            "destinationVille": "0",
            "date": null,
            "thDepart": null,
            "acheteur": null,
            "destinateur": null,
            "codeAcheteur": null,
            "nomMagasin": null,
            "sacs": null,
            "poids": null,
            "prix": null,
            "nomTransporteur": null,
            "contactTransporteur": null,
            "immatriculation": null,
            "remorque": null,
            "avantCamion": null,
            "nomChauffeur": null,
            "permisConduire": null,
            "dest_date_dechargement": null,
            "dest_heure": null,
            "dest_nom_exportateur": null,
            "dest_code_exportateur": null,
            "dest_port_usine_dechargement": null,
            "dest_pont_bascule": null,
            "dest_nom_magasin": null,
            "dest_kor": null,
            "dest_nombre_sacs_decharges": null,
            "dest_nombre_sacs_rembourses": null,
            "dest_taux_humidite": null,
            "dest_poids_brut": null,
            "dest_tare": null,
            "dest_poids_net": null,
            "dest_prix_kg": null,
            "numeroFiche": "006762762",
            "campagne": "2025-2026",
            "bundle_id": null,
            "sticker": "S6767762",
            "image": null,
            "status": "PENDING",
            "created_at": "2026-01-26T21:25:13.878922Z",
            "updated_at": "2026-01-26T21:25:13.878926Z"
        },
    ],
    "total": 4,
    "page": 1,
    "size": 50,
    "pages": 1
}
Aussi il faut afficher toutes les informations du chargement ou déchargement dans les pages de détail au lieu d'afficher que celles du déchargement des chargements ou déchargements.

////////////
Dans mon système actuel, analyse et apporte apporter des corrections :
Quand l'utilisateur se connecte, la session est persistée mais au redemarrage de l'application, on demande encore de se connecter, il faut corriger ça. 
Quand le token n'a pas encore expiré, il faut rediriger l'utilisateur vers la page d'accueil au lieu de demander de se connecter.

Le deuxieme point c'est si le rôle de l'utilisateur est différent de agent, on ne doit pas faire de syncrhonisation, il faut rediriger l'utilisateur vers la page d'accueil.

Le troisieme point, permettre de cliquer sur HomeCards dans AgentRelaisDashboard pour voir les fiches synchronisées et Fiches ajoutées.

Dans la page des fiches(TranfertsPage) il faut créer une page de détail pour afficher les détails de la fiche avec les images des reçus et fiche, utilise cet exemple de template en dessous :



///////

Je veux que tu fasse ces ameliorations sur l'application :

1. Inspire toi du design de TransfertDetailPage pour afficher les détails d'un chargement ou déchargement dans la page de détail(LoadingDetailPage et UnloadingDetailPage).
   Pour afficher les images d'un chargement ou déchargement, il faut les récuperer par api : GET /commodities/receipts/ avec le bundleId dans le chargement en parametre.

Voici un exemple de réponse de l'api pour récuperer les reçus :
{
    "items": [
         {
            "numeroRecu": "4477253",
            "campagne": "2025-2026",
            "bundle_id": "44772514477253",
            "image": "image_475b5e99.jpg",
            "date": null,
            "departement": null,
            "typeTransfert": null,
            "sousPrefecture": null,
            "village": null,
            "numeroAgrement": null,
            "nomAcheteur": null,
            "nomPisteur": null,
            "contactPisteur": null,
            "nomProducteur": null,
            "villageProducteur": null,
            "contactProducteur": null,
            "nbSacsAchetes": null,
            "nbSacsRembourses": null,
            "poidsTotal": null,
            "prixUnitaire": null,
            "valeurTotale": null,
            "montantPaye": null
        },
    ],
    "total": 0,
    "page": 1,
    "size": 1,
    "pages": 0
}